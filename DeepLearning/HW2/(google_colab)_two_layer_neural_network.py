# -*- coding: utf-8 -*-
"""(Google Colab) Two-Layer-Neural-Network.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19sQorVGHmw4472ZVsIw7NyVCLALjHzVn
"""

# [Input Vars]
#   1. <ndarray> Z

# [Output Vars]
#   1. <ndarray> A

import numpy as np

def Sigmoid(Z):
  A = 1/(1 + np.exp(-Z))
  return A


# [Input Vars]
#   1. <ndarray> A

# [Output Vars]
#   1. <ndarray> S

def Softmax(A):
  Y_pred = np.exp(A-np.max(A))/np.sum(np.exp(A-np.max(A)))
  return Y_pred

# [Input Vars]
#   1. <ndarray> X: Its shape should be (1, 769).
#   2. <ndarray> W1: Its shape should be (769, 300).
#   3. <ndarray> W2: Its shape should be (300, 50).

# [Output Vars] 
#   1. <ndarray> S: Its shape should be (1, 50).
#   2. <ndarray> a2: Its shape should be (1, 50).
#   3. <ndarray> a1: Its shape should be (1, 300).

import numpy as np

def forward_pass(X, W1, W2):

  assert X.shape == (1, 769), f"[Error] X's shape is {X.shape}. Expected shape is (1, 769)."
  assert W1.shape == (769, 300), f"[Error] W1's shape is {W1.shape}. Expected shape is (769, 300)."
  assert W2.shape == (300, 50), f"[Error] W2's shape is {W2.shape}. Expected shape is (300, 50)."

  Z1 = np.dot(X, W1)
  assert Z1.shape == (1, 300), f"[Error] Z1's shape is {Z1.shape}. Expected shape is (1, 300)."

  A1 = Sigmoid(Z1)
  assert A1.shape == (1, 300), f"[Error] A1's shape is {A1.shape}. Expected shape is (1, 300)."

  Z2 = np.dot(A1, W2)
  assert Z2.shape == (1, 50), f"[Error] Z2's shape is {Z2.shape}. Expected shape is (1, 50)."

  A2 = Sigmoid(Z2)
  assert A2.shape == (1, 50), f"[Error] A2's shape is {A2.shape}. Expected shape is (1, 50)."

  Y_pred = Softmax(A2)
  assert Y_pred.shape == (1, 50), f"[Error] Y_pred's shape is {S.shape}. Expected shape is (1, 50)."

  return Y_pred, A2, A1

# [Input Vars]
#   1. <ndarray> Y_pred: Its shape should be (1, 50).
#   2. <ndarray> Y_truth: Its shape should be (1, 50).

# [Output Vars]
#   2. <ndarray> Error

import numpy as np

def CrossEntropy(Y_pred, Y_truth):
  assert Y_truth.shape == (1, 50), f"[Error] Y_truth's shape is {Y_truth.shape}. Expected shape is (1, 50)."
  assert Y_pred.shape == (1, 50), f"[Error] Y_pred's shape is {S.shape}. Expected shape is (1, 50)."

  Error = (-1 * Y_truth * np.log(Y_pred)).sum()
  return Error

# [Input Vars]
#   1. <ndarray> Y_pred: Its shape should be (1, 50).
#   2. <ndarray> Y_truth: Its shape should be (1, 50).
#   3. <ndarray> A2: Its shape should be (1, 50).
#   4. <ndarray> A1: Its shape should be (1, 300).
#   5. <ndarray> X: Its shape should be (1, 769).
#   6. <ndarray> W2: Its shape should be (300, 50).
#   7. <ndarray> W1: Its shape should be (769, 300).

# [Output Vars]
#   1. <ndarray> dEdW1: Its shape should be the same as W1, which is (769, 300).
#   2. <ndarray> dEdW2: Its shape should be the same as W2, which is (300, 50).

import numpy as np

def backward_pass(Y_pred, Y_truth, A2, A1, X, W2, W1):
  assert Y_pred.shape == (1, 50), f"[Error] Y_pred's shape is {Y_pred.shape}. Expected shape is (1, 50)."
  assert Y_truth.shape == (1, 50), f"[Error] Y_truth's shape is {Y_truth.shape}. Expected shape is (1, 50)."
  assert A2.shape == (1, 50), f"[Error] A2's shape is {A2.shape}. Expected shape is (1, 50)."
  assert A1.shape == (1, 300), f"[Error] A1's shape is {A1.shape}. Expected shape is (1, 300)."
  assert X.shape == (1, 769), f"[Error] X's shape is {X.shape}. Expected shape is (1, 769)."

  dEdA2 = Y_pred - Y_truth
  assert dEdA2.shape == (1, 50), f"[Error] dEdA2's shape is {dEdA2.shape}. Expected shape is (1, 50)."
  
  dZ2_local = np.multiply(1 - A2, A2)
  dEdZ2 = np.multiply(dZ2_local, dEdA2)
  assert dEdZ2.shape == (1, 50), f"[Error] dEdZ2's shape is {dEdZ2.shape}. Expected shape is (1, 50)."

  dEdW2 = np.outer(A1, dEdZ2)
  assert dEdW2.shape == (300, 50), f"[Error] dEdW2's shape is {dEdW2.shape}. Expected shape is (300, 50)."

  dEdA1 = np.dot(dEdZ2, W2.T)
  assert dEdA1.shape == (1, 300), f"[Error] dEdA1's shape is {dEdA1.shape}. Expected shape is (1, 300)."

  dZ1_local = np.multiply(1 - A1, A1)
  dEdZ1 = np.multiply(dZ1_local, dEdA1)
  assert dEdZ1.shape == (1, 300), f"[Error] dEdZ1's shape is {dEdZ1.shape}. Expected shape is (1, 300)."

  dEdW1 = np.outer(X, dEdZ1)
  assert dEdW1.shape == (769, 300), f"[Error] dEdW1's shape is {dEdW1.shape}. Expected shape is (769, 300)."

  dEdX = np.dot(dEdZ1, W1.T)
  assert dEdX.shape == (1, 769), f"[Error] dEdX.shape's shape is {dEdX.shape}. Expected shape is (1, 769)."

  return dEdW1, dEdW2

# [Input Vars]
#   1. <ndarray> dEdW1
#   2. <ndarray> dEdW2
#   3. <ndarray> W1
#   4. <ndarray> W2
#   5. <float> lr

# [Output Vars]
#   1. <ndarray>
#   2. <ndarray>

import numpy as np

def update_weights(dEdW1, dEdW2, W1, W2, lr):
  W1 = W1 - lr * dEdW1
  W2 = W2 - lr * dEdW2
  return W1, W2

